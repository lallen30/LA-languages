import { Component, OnInit, OnDestroy, NgZone } from '@angular/core';
import { IonicModule } from '@ionic/angular';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { Router } from '@angular/router';
import { addIcons } from 'ionicons';
import { 
  add, 
  refresh,
  cloudDownloadOutline,
  createOutline,
  ellipsisVertical,
  libraryOutline,
  refreshOutline,
  addOutline,
  close,
  statsChartOutline,
  trashOutline
} from 'ionicons/icons';

@Component({
  selector: 'app-decks',
  templateUrl: './decks.page.html',
  styleUrls: ['./decks.page.scss'],
  standalone: true,
  imports: [IonicModule, CommonModule, FormsModule]
})
export class DecksPage implements OnInit, OnDestroy {
  filteredDecks: any[] = [
    {
      id: '1',
      name: 'Spanish Basics',
      description: 'Essential Spanish phrases for beginners',
      cardCount: 25,
      masteredCards: 0,
      language: 'es-ES'
    }
  ];
  
  selectedLanguage = 'es-ES';
  isLoading = false;
  
  // Modal and menu states
  showCreateDeckModal: boolean = false;
  showImportMenuModal: boolean = false;
  showDeckMenuModal: boolean = false;
  showAddCardMenuModal: boolean = false;
  
  // Form data
  newDeckName: string = '';
  newDeckDescription: string = '';
  selectedDeck: any = null;
  
  languages = [
    { code: 'es-ES', name: 'Spanish' },
    { code: 'fr-FR', name: 'French' },
    { code: 'de-DE', name: 'German' }
  ];

  constructor(
    private router: Router,
    private ngZone: NgZone
  ) {
    // Register required icons
    addIcons({ 
      add, 
      refresh,
      cloudDownloadOutline,
      createOutline,
      ellipsisVertical,
      libraryOutline,
      refreshOutline,
      addOutline,
      close,
      statsChartOutline,
      trashOutline
    });
  }

  ngOnInit() {
    console.log('DecksPage initialized with iOS header fix');
    console.log('Testing JavaScript execution on iOS');
    console.log('Filtered decks:', this.filteredDecks);
    
    // Add native event listeners as fallback for iOS
    setTimeout(() => {
      this.setupNativeEventListeners();
    }, 100);
  }

  private setupNativeEventListeners() {
    console.log('Setting up native event listeners for iOS');
    // Note: With the new professional UI, all interactions use Angular event binding
    // This method is kept for compatibility but no longer needed
      button.addEventListener('click', (event) => {
        console.log(`Native deck button ${index} clicked!`);
        event.stopPropagation();
        this.ngZone.run(() => {
          if (this.filteredDecks[index]) {
            this.manageDeck(this.filteredDecks[index], event);
          }
        });
      });
    });
  }

  ngOnDestroy() {
    console.log('DecksPage destroyed');
  }

  // Simple test method to verify JavaScript execution
  testClick() {
    console.log('TEST CLICK WORKED!');
    alert('Test click successful!');
  }

  trackByDeckId(index: number, deck: any): string {
    return deck.id;
  }

  getDeckColor(deckId: string): string {
    const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4'];
    // Use a simple hash of the deckId to ensure consistent color selection
    let hash = 0;
    for (let i = 0; i < deckId.length; i++) {
      const char = deckId.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32-bit integer
    }
    return colors[Math.abs(hash) % colors.length];
  }

  onLanguageChange() {
    console.log('Language changed to:', this.selectedLanguage);
  }

  async refreshDecks() {
    console.log('Refreshing decks...');
    this.isLoading = true;
    
    // Simulate API call
    setTimeout(() => {
      this.isLoading = false;
      alert('Decks refreshed successfully!');
    }, 1000);
  }

  importFromDevice() {
    alert('Import from device feature coming soon!');
  }

  importFromUrl() {
    const url = prompt('Enter deck URL:');
    if (url) {
      alert('URL import feature coming soon!');
    }
  }

  createDeck() {
    if (!this.newDeckName?.trim()) return;
    
    const newDeck = {
      id: Date.now().toString(),
      name: this.newDeckName.trim(),
      description: this.newDeckDescription?.trim() || '',
      cardCount: 0,
      masteredCards: 0,
      language: this.selectedLanguage
    };
    
    this.filteredDecks.push(newDeck);
    this.hideCreateModal();
    alert(`Deck "${newDeck.name}" created successfully!`);
  }

  // Refresh functionality
  async refreshDecks() {
    this.isLoading = true;
    
    // Simulate API call
    setTimeout(() => {
      this.isLoading = false;
      alert('Decks refreshed successfully!');
    }, 1500);
  }

  // Deck management methods
  editDeck(deck: any) {
    const newName = prompt('Edit deck name:', deck.name);
    if (newName && newName.trim() !== deck.name) {
      deck.name = newName.trim();
      alert('Deck updated successfully!');
    }
  }

  deleteDeck(deck: any) {
    if (confirm(`Are you sure you want to delete "${deck.name}"? This action cannot be undone.`)) {
      const index = this.filteredDecks.indexOf(deck);
      if (index > -1) {
        this.filteredDecks.splice(index, 1);
        alert('Deck deleted successfully!');
      }
    }
  }

  exportDeck(deck: any) {
    alert('Export deck feature coming soon!');
  }

  manageCards(deck: any) {
    alert('Manage cards feature coming soon!');
  }

  viewStats(deck: any) {
    const stats = `Deck: ${deck.name}\n\nTotal Cards: ${deck.cardCount}\nMastered: ${deck.masteredCards}\nRemaining: ${deck.cardCount - deck.masteredCards}\nProgress: ${deck.cardCount > 0 ? Math.round((deck.masteredCards / deck.cardCount) * 100) : 0}%`;
    alert(stats);
  }

  async startSession(deck: any) {
    console.log('Starting session with deck:', deck.name);
    
    if (deck.cardCount === 0) {
      alert('This deck has no cards yet. Add some cards first!');
      return;
    }
    
    // Navigate to study session
    // this.router.navigate(['/study', deck.id]);
    alert('Study session feature coming soon!');
  }

  async manageDeck(deck: any, event: Event) {
    event.stopPropagation();
    
    // iOS fallback using native confirm/prompt
    const choice = confirm(`Manage "${deck.name}":\n\n1. Edit Deck\n2. Add Cards\n3. View Stats\n4. Delete Deck\n\nTap OK to see options, Cancel to close`);
    
    if (choice) {
      const action = prompt('Enter your choice:\n1 - Edit Deck\n2 - Add Cards\n3 - View Stats\n4 - Delete Deck', '1');
      
      switch (action) {
        case '1':
          this.editDeck(deck);
          break;
        case '2':
          this.addCards(deck);
          break;
        case '3':
          this.viewStats(deck);
          break;
        case '4':
          this.deleteDeck(deck);
          break;
        default:
          console.log('Invalid choice or cancelled');
      }
    }
  }

  async editDeck(deck: any) {
    const name = prompt('Enter new deck name:', deck.name);
    if (name && name.trim()) {
      const description = prompt('Enter new deck description:', deck.description) || '';
      deck.name = name.trim();
      deck.description = description.trim();
      alert('Deck updated successfully!');
    }
  }

  addCards(deck: any) {
    this.showAddCardMenu(deck);
  }

  addCardType(type: string) {
    switch(type) {
      case 'fill-blank':
        alert('Fill in the Blank card creation coming soon!');
        break;
      case 'picture':
        alert('Picture Word card creation coming soon!');
        break;
      case 'translate':
        alert('Translation card creation coming soon!');
        break;
    }
  }

  async viewStats(deck: any) {
    const progress = deck.cardCount > 0 ? Math.round((deck.masteredCards / deck.cardCount) * 100) : 0;
    const language = this.languages.find(l => l.code === deck.language)?.name || 'Unknown';
    
    alert(`"${deck.name}" Statistics:\n\nTotal Cards: ${deck.cardCount}\nMastered: ${deck.masteredCards}\nProgress: ${progress}%\nLanguage: ${language}`);
  }

  async deleteDeck(deck: any) {
    const confirmed = confirm(`Are you sure you want to delete "${deck.name}"? This action cannot be undone.`);
    if (confirmed) {
      const index = this.filteredDecks.findIndex(d => d.id === deck.id);
      if (index > -1) {
        this.filteredDecks.splice(index, 1);
        alert(`Deck "${deck.name}" deleted successfully!`);
      }
    }
  }

  // Header menu method - iOS-compatible custom menu
  // Modal and menu control methods
  showCreateModal() {
    this.newDeckName = '';
    this.newDeckDescription = '';
    this.showCreateDeckModal = true;
  }

  hideCreateModal() {
    this.showCreateDeckModal = false;
  }

  showImportMenu() {
    this.showImportMenuModal = true;
  }

  hideImportMenu() {
    this.showImportMenuModal = false;
  }

  showDeckMenu(deck: any) {
    this.selectedDeck = deck;
    this.showDeckMenuModal = true;
  }

  hideDeckMenu() {
    this.showDeckMenuModal = false;
    this.selectedDeck = null;
  }

  showAddCardMenu(deck: any) {
    this.selectedDeck = deck;
    this.showAddCardMenuModal = true;
  }

  hideAddCardMenu() {
    this.showAddCardMenuModal = false;
    this.selectedDeck = null;
  }
}
